

Chapter 7: Adding Functionality to the App
==========================================

Kiana and Maria are excited to show the inventory management app to Caleb, the field technician. He likes it, but suggests adding some extra user interface functionality to make it easier to use. Specifically, Caleb would like to be able to:

-   Add a photograph of the work done on a boiler or air conditioning unit, and add it to the appointment details on the **Edit Appointment** screen. This image could prove useful as documentary evidence of repairs performed. The **Edit Appointment** screen currently enables the user to add an image to the appointment, but the image isn't saved as this feature hasn't been fully implemented yet. The reason for this omission is that Kiana and Preeti need to determine the best place to store image data. Caleb would like this functionality added as soon as possible.


-   View a complete appointment history for a customer, to track repairs requested for that customer and monitor any ongoing issues that may require repeated callouts.

-   Order parts from the **Part Details** screen.

    Additionally, the image control on the **Part Details** screen displays the images stored at a specified URL. Currently the URLs in the data are simply placeholders. Like the photographs for the appointment screen, Kiana and Preeti need to determine the best place to store images so they're available to the Power App.

## Adding a Photograph to an Appointment

Photographs need to be stored somewhere accessible by the Power App. For performance and security reasons, Preeti doesn't want photographs to be saved in OneDrive or in Azure SQL Database. Instead, she and Kiana decide to use Azure Blob Storage. Blob Storage is optimized for holding large binary objects, and is robust, with built-in security. Power Apps has a connector that allows access to Blob Storage. Maria suggests adding a new picture-taking screen, improving the user experience for Caleb.

> **NOTE:**
> For detailed information, visit the **Azure Blob Storage** page at <https://azure.microsoft.com/services/storage/blobs/>.

Preeti creates the Blob Storage account from the Azure portal:

1.  In the Azure portal, on the **Home** page, select **+ Create a resource**. In the **Search the Marketplace** box, enter **Storage account** and press **Enter**.

    ![Azure Marketplace search][161]

2.  On the **Storage account** page, select **Create**.

3.  On the **Create storage account** page, enter the following details, and then select **Review + create**:

    -   Subscription: Select your subscription
    -   Resource group: **webapi\_rg**
    -   Storage account name: Provide a globally unique name and make a note of it for later
    -   Location: Select your nearest location
    -   Performance: **Standard**
    -   Account kind: **BlobStorage**
    -   Replication: **RA-GRS**

    ![Create the Azure Storage account][162]

4.  On the validation page, select **Create** and wait for the storage account to be provisioned.

5.  Go to the page for the new storage account.

6.  On the **Overview** page, select **Containers**:

    ![Storage account Overview page][163]

7.  On the **Containers** page, select **+ Container**. Create a new container named **photos**, and then select **Create**. Change the public access level** to **Blob**:

    ![Create the Photos container][164]

8.  Back on the **Overview** page for the storage account, under settings, select **Access keys**. On the **Access keys** page, select **Show keys.** Make a note of the value of the key for **key1**:

    ![Storage account access keys][165]

Preeti gives the storage account name and key to Kiana, who uses this information to create a custom connector for the Power App:

1.  Sign in to Power Apps Studio at <http://make.powerapps.com>.

2.  In the left pane, expand **Data**, and select **Connections**. The existing connections used by the app should be listed. Select **+ New connection**:

    ![Power Apps connections page][166]

3.  On the **New connection** page, scroll down, select **Connections**, select **Azure Blob Storage**, and then select **Create**:

    ![Select Azure Blob Storage connector][167]

4.  In the **Azure Blob Storage** dialog box, enter the storage account name and access key that Preeti provided, and then select **Create**:

    ![Enter storage credentials][168]

5.  Wait while the new connection is created. It should appear on the list of connections.

Maria can use this connection to Azure Blob Storage in the app to save and retrieve photographic images. Her first task is to add the connection to the app:

1.  Open the **VanArsdelApp** app for editing in Power Apps Studio.

2.  In the **Data** pane, select **Add data**, search for the **Azure Blob Storage** connector, and then select this connector:

    ![Search for the Blob Storage connector][169]

3.  In the **Azure Blob Storage** dialog box, select the **Azure Blob Storage** connector to add it to your Power App:

    ![Add Blob Storage connection][170]

Maria's next task is to add a screen that enables a technician or engineer to save a photograph. Maria decides to add a new screen with a Picture control. When the app is run on a mobile device, this control can integrate with the camera to enable the technician to take a photograph. On other devices, this control prompts the user to upload an image file instead. She adds a link to this new screen from the **EditAppointment** screen:

1.  On the **Insert** menu, select **New screen**, and then select the **Scrollable** template:

    ![New screen from the Scrollable template][171]

2.  In the **Tree view** pane, select the new screen and rename it as **TakePhoto**.

3.  Change the **Text** property of the **LblAppName*X*** control on this screen to **Take a photograph**.

4.  Delete the **Canvas*X*** control from the screen.

5.  In the **Insert** menu, from the **Media** drop-down list, select **Add picture** to create a new picture control:

    ![Add a Picture control][172]

    > **NOTE:**
    > The picture control is actually a composite custom component that enables the user to add a picture to the screen and display the results.

6.  Resize and reposition the picture control to occupy the body of the screen.

7.  In the **Tree view** pane, select the **IconBackarrow*X*** control on the **AppointmentDetails** screen, and select **Copy**:

    ![Copy the Back Arrow control][173]

8.  In the **Tree view** menu, right-click the **TakePhoto** screen, and then select **Paste**. The **IconBackArrow*X*** control will be added to the screen:

    ![Paste the Back Arrow control in the TakePhoto screen][174]

9.  Move the **IconBackArrow*X*** control to the top left of the header bar.

10. In the **Tree view** pane, select the **IconBackArrow*X*** control on the **TakePhoto** screen. In the right pane, on the **Advanced** tab, modify the **OnSelect** action property to **Navigate(EditAppointment, ScreenTransition.None)**.

11. Add a new **Save** icon control to the top right of the header bar. Set the **Visible** property of this control to **If(IsBlank(AddMediaButton1.Media), false, true)**.

    This setting makes the **Save** icon invisible if the user hasn't selected an image.

    ![Add Save icon control][175]

12. Change the formula in the **OnSelect** action property of the **Save** icon control to:

    ```
    Set(ImageID, GUID() & ".jpg");

    AzureBlobStorage.CreateFile("photos", ImageID, AddMediaButton1.Media);

    Patch(appointmentsCollection, LookUp(appointmentsCollection,id=BrowseAppointmentsGallery.Selected.id), {imageUrl:"https://myappphotos.blob.core.windows.net/photos/" & ImageID});

    Navigate(EditAppointment,ScreenTransition.Cover);
    ```

    Replace **\<storage account name\>** with the name of the Azure storage account that Preeti created.

    This code uploads the image to the **photos** container in Azure Blob Storage. Each image is given a unique filename. The **Patch** function updates the **imageUrl** property in the appointments record with the URL of the image in Blob Storage.

13. In the **Tree view** pane, expand the **AddMediaWithImageX** control. Modify the **Image** property of the **UploadedImage*X*** control, and set it to **AppointmentImage**.

    AppointmentImage is a variable that will be populated with an image either uploaded by the user, or as the result of taking a photograph. You'll initialize this variable in the **EditAppointment** screen later.

14. In the **Tree view** pane, select the **AddMediaButton*X*** control. Set the **UseMobileCamera** property of this control to **true**. Set the **OnChange** action property of the control to:

    ```
    Set(AppointmentImage, AddMediaButton1.Media)
    ```

    This formula changes the **AppointmentImage** variable to reference the new image. The **UploadedImage*X*** control will display this image.

15. In the **Tree view** pane, select the **EditAppointment** screen.

16. Expand the **EditForm*X*** control. Under the **Image\_DataCardX** control, remove the **AddPictureX** control:

    ![Remove the AddPicture control][176]

17. Select the **Image*X*** control. Change the following properties:

    -   Image: **Parent.Default**
    -   X: **30**
    -   Y: **DataCardKey*X*.Y + DataCardKey*X*.Height + 150** (where **DataCardKey*X*** is the data card containing the **Image*X*** control)
    -   Width: **Parent.Width - 60**
    -   Height: **400**

    > **NOTE:**
    > The image control will drop down below the bottom of the screen, but a scroll bar will be added automatically to enable the image to be viewed.

18. Add a **Camera** icon to the data card then position it between the **Image** label and the **ImageX** control. Change the name of the control to **CameraIcon**:

    > **NOTE:**
    > Make sure you select the Camera Icon control, and **not** the Camera Media control.

    ![Add Camera icon][177]

19. Set the **OnSelect** action property of the **CameraIcon** control to:

    ```
    Set(AppointmentImage, SampleImage);

    Navigate(TakePhoto, ScreenTransition.None);
    ```

    When the user clicks this icon, they will go to the **TakePhoto** screen, to enable them to take a photo or upload an image. The initial image displayed will be the default sample image.

To test the app:

1.  In the **Tree view** pane, select the **Home** screen.

2.  Press **F5** to preview the app.

3.  On the **Home** screen, select **Appointments**.

4.  In the browse screen, select any appointment.

5.  On the details screen for the appointment, select the edit icon in the screen header.

6.  On the edit screen, select the **Camera** icon for the image.

7.  Verify that the **Take a photograph** screen appears.

8.  Select **Change Picture** and upload a picture of your choice (or take a photograph if you're running on a mobile device).

9.  Select **Save**. Verify that the image appears on the details page, and then select the tick icon to save the changes back to the database.

10. Close the preview window and return to Power Apps Studio.

## Displaying Images of Parts

Having determined that Azure Blob Storage is an ideal location for saving pictures associated with appointments, Preeti and Kiana decide that they should use the same approach for storing the images of parts. A key advantage of this approach is that it doesn't require any modifications to the Power Apps app. The app reuses the same storage account and the same connection. As a separate migration exercise, they can:

1.  Create a new Blob container.

2.  Upload the part images to this container.

3.  Change the **ImageUrl** references in the **Parts** table in the **InventoryDB** database to the URL of each image.

The app will pick up the new URL for each part image automatically, and the **Image** control on the **PartDetails** screen will display the image.

## Tracking Appointment History for a Customer

Maria thinks that being able to quickly view all the history from a customer's previous technician's visits could be added to the app by creating a custom component. Working with Caleb on what information they want to see, Maria sketches out a simple design comprising the notes and the date of each visit.

![Data for the customer appointment history][178]

Looking at the data, Maria believes that a gallery control is the best way to display the table data on a screen.

Maria creates the custom component as follows:

1.  Using Power Apps Studio, in the **Tree view** pane, select **Components**, and then select **+ New component**:

    ![Create a new component][179]

    A new blank component named **Component1** is created. Rename the component as **DateHistoryComponent**:

    ![Rename the component][180]

2.  On the **Insert** menu, select **Gallery**, and then choose the **Blank flexible height** gallery template:

    ![Add a Gallery control][181]

3.  Move the gallery control and resize it to fill the custom component.

4.  Select the **Add an item from the insert pane**, then select **Text label**.

    ![Add a Text label to the component][182]

5.  In the **Tree view** pane, rename the label control as **NotesLabel**. Set the **Overflow** property to **Overflow.Scroll**. This setting enables the control to display several lines of text and allow the user to scroll through it. Set the following properties so you can position and size the control:

    -   LineHeight: **2**
    -   X: **28**
    -   Y: **18**
    -   Width: **574**
    -   Height: **140**

6.  Add a second text label to the control. Rename this control as **DateLabel** and set the following properties:

    -   LineHeight: **2**
    -   X: **28**
    -   Y: **174**
    -   Width: **574**
    -   Height: **70**

7.  To see how the control will look when inserted into the app and using its theme, in the **Tree view** pane, select **DateHistoryComponent**. In the right pane, on the **Advanced** tab, select the **Fill** field and change the color to **RGBA(0, 0, 0, 1)**.

    ![View the component][183]

8.  From the **Insert** pane, expand **Shapes**, and add a **Rectangle** control to the custom component. Set the following properties for this control:

    -   X: **0**
    -   Y: **273**
    -   Width: **Parent.Width**
    -   Height: **2**

    This control acts as a separator between the records displayed in the gallery:

    ![Add a Rectangle control][184]

Maria is familiar with adding controls to screens and building Power Apps. However, reusable components don't work in quite the same way. Kiana described to Maria that to be able to use data in a custom component, she must add some additional custom input properties. Kiana also explained that Maria needs to provide example data for these properties, to allow her to reference the data fields in the controls in her component, as follows:

1.  In the **Tree view** pane, select **DateHistoryComponent**. In the right pane, on the **Properties** tab, select **New custom property**:

    ![New custom property][185]

2.  In the **New custom property** dialog box, specify the following values, and then select **Create**:

    -   Display name: **Data**
    -   Name: **Data**
    -   Description: **The table of appointments for a customer, showing the notes and dates**
    -   Property type: **Input**
    -   Data type: **Table**
    -   Raise OnReset when value changes: Leave blank

    ![New custom property properties][186]

3.  To change the sample data displayed by the control, select the new **Data** custom property. In the formula field, type **Table({Notes: "Example notes field text.", \'Appointment Date\': Text(Today())})**.

    ![Change the sample data][187]

4.  In the **Tree view** pane, select the **Gallery*X*** control in **DateHistoryComponent**, and rename it as **AppointmentHistory**.

5.  In the right pane, on the **Advanced** tab, set the **Items** property of the **AppointmentHistory** gallery control to **Parents.Data**.

    ![Update the Items property for the gallery control][188]

6.  Select the **NotesLabel** control. In the right pane on the **Advanced** tab, change the **Text** property to **ThisItem.Notes,** and change the **Size** property to **20**.

    > **NOTE:**
    > The **Size** property specifies the font size for the text displayed by the control.

7.  Select the **DateLabel** control to change the **Text** property to **ThisItem.\'Appointment Date\'** and change the **Size** property to **20**. The fields in the custom component should display the sample data:

    ![Custom component with sample data][189]

The custom component is complete. Maria creates a new screen to display the appointments history for a customer using this component:

1.  In the **Tree view** pane, select the **Screens** tab.

2.  Expand the **BrowseAppointments** screen, expand the **BrowseAppointmentsGallery** control, and select the **Body1\_1** control. On the **Insert** menu, select **Icons**, and then select the **Detail list** icon:

    ![Add Details list icon][190]

3.  Change the name of the icon control to **ViewAppointments**.

4.  In the **Tree view** menu, select the **BrowseAppointmentsGallery** control. In the right pane, on the **Advanced** tab, change the **TemplateSize** property to **220**. Increasing this property expands the space available in the gallery.

5.  Move the **ViewAppointments** icon into the empty space below the customer name:

    ![Amended appoinments gallery][191]

6.  Select the **ViewAppointments** icon control. Set the **OnSelect** action property to the following formula:

    ```
    ClearCollect(customerAppointmentsCollection, FieldEngineerAPI.getapicustomeridappointments(ThisItem.customerId));

    Navigate(AppointmentsHistoryScreen, ScreenTransition.Fade)
    ```

    This formula populates a collection named **customerAppointmentsCollection** with the appointments for the selected customer, and then moves to the **AppointmentHistoryScreen** to display them. You'll create this screen in the following steps.

7.  On the **Insert** menu, select **New screen**, and then select the **Scrollable** template:

    ![New screen based on the Scrollable template][192]

8.  Change the name of the new screen to **AppointmentHistoryScreen**.

9.  Delete the **Canvas*X*** control that was added to this screen:

    ![Delete the Canvas control][193]

10. Select the **LblAppName*X*** control on this screen. In the right pane, on the **Advanced** tab, change the **Text** property to:

    ```
    "Appointments History for " &  BrowseAppointmentsGallery.Selected.customer.name
    ```

11. Set the following properties for the **LblAppName*X*** control to adjust the position and size:

    -   X: **90**
    -   Y: **0**
    -   Width: **550**
    -   Height: **140**

12. Select the **RectQuickActionBar*X*** control, and set the **Height** property to **140**.

13. Add a **Left icon** control to the screen header, to the left of the title. Set the **OnSelect** action property for this control to **Navigate(BrowseAppointments, Transition.None)**.

    ![Empty AppointmentsHistory screen][194]

14. On the **Insert** menu, select **Custom**, and then select the **DateHistoryComponent**:

    ![Add DateHistory component][195]

15. Move and resize the component so that it occupies the body of the screen, below the heading:

    ![Resized component][196]

16. Set the following properties for this component:

    -   Data: **customerAppointmentsCollection**
    -   Appointment Date: **startDateTime**
    -   Notes: **notes**

17. Save the Power Apps app.

To test the Power Apps app:

1.  In the **Tree view** pane, select the **Home** screen.

2.  Press **F5** to preview app.

3.  On the **Home** screen, select **Appointments**.

4.  In the browse screen, select the **Detail list** icon for any appointment.

5.  Verify that the **Appointments History** screen for the selected customer appears.

6.  Close the preview window and return to Power Apps Studio.

## Ordering Parts

A key requirement of the system is to enable a technician to order any parts required while visiting a customer. If the parts are in stock, it should be possible to schedule another visit to complete the repair at the next convenient date for the customer. If the parts are currently out of stock and have to be ordered, the technician can tell the customer. Malik can then arrange an appointment with the customer when Maria receives notice that the parts have arrived in the warehouse.

The reservations part of the app uses the tables in the **InventoryDB** database shown in the diagram below. The **Orders** table holds information about orders placed for parts. The **Reservations** table lists the reservation requests that technicians and engineers have made for parts. The **Engineers** table provides the name and contact number for the engineer who made the reservation, in case of any queries by Maria, the inventory manager.

![The Reservations data model][197]

To support this feature, Kiana has to update the Web API with a method that fetches the number of reserved items for a specified part:

1.  Open the **FieldEngineerApi** Web API project in Visual Studio Code.

2.  Add a file named **Order.cs** to the **Models** folder. Add the following code to this file. The **Orders** class tracks the details of orders placed for parts.

    ```csharp
    using System;
    using System.ComponentModel.DataAnnotations;
    using System.ComponentModel.DataAnnotations.Schema;

    namespace FieldEngineerApi.Models
    {
        public class Order 
        {
            [Key]
            public long Id { get; set; }

            public long BoilerPartId { get; set; }

            public BoilerPart BoilerPart { get; set; }

            public long Quantity { get; set; }

            [Column(TypeName = "money")]
            public decimal TotalPrice { get; set; }

            [Display(Name = "OrderedDate")]
            [DataType(DataType.DateTime)]
            [DisplayFormat(DataFormatString = "{0:MM/dd/yyyy}")]
            public DateTime OrderedDateTime { get; set; }

            public bool Delivered { get; set; }

            [Display(Name = "DeliveredDate")]
            [DataType(DataType.DateTime)]
            [DisplayFormat(DataFormatString = "{0:MM/dd/yyyy}")]
            public DateTime? DeliveredDateTime { get; set; }
        }
    }
    ```

3.  Add another new file named **Reservation.cs** to the **Models** folder and add the code shown below to this file. The **Reservation** class contains information about the number of items for a given part that are currently reserved for other customers.

    ```csharp
    using System;
    using System.ComponentModel.DataAnnotations;

    namespace FieldEngineerApi.Models
    {
        public class Reservation
        {
            [Key]
            public long Id { get; set; }

            public long BoilerPartId { get; set; }

            public BoilerPart BoilerPart { get; set; }

            public int NumberToReserve { get; set; }

            public string EngineerId { get; set; }

            public InventoryEngineer Engineer { get; set; }
        }
    }
    ```

4.  Add one more file, named **InventoryEngineer.cs,** to the **Models** folder, with the following code. The **InventoryEngineer** class records which engineers have made which reservations:

    ```csharp
    using System.ComponentModel.DataAnnotations;
    using System.Collections.Generic;

    namespace FieldEngineerApi.Models
    {
        public class InventoryEngineer
        {
            [Key]
            public string Id { get; set; }

            [Required]
            public string Name { get; set; }

            public string ContactNumber { get; set; }

            public List<Reservation> Reservations { get; set; }
        }
    }
    ```

5.  Open the **InventoryContext.cs** file in the **Models** folder, and add the statements shown below to the **InventoryContext** class:

    ```csharp
    public class InventoryContext : DbContext
    {
        public InventoryContext(DbContextOptions\<InventoryContext\> options)
            : base(options)
        {

        }

        public DbSet<BoilerPart> BoilerParts { get; set; }
        public DbSet<InventoryEngineer> Engineers { get; set; }
        public DbSet<Order> Orders { get; set; }
        public DbSet<Reservation> Reservations { get; set; }
    }
    ```

6.  In the Terminal window in Visual Studio Code, run the following commands to build controllers for handling orders and reservations:

    ```shell
    dotnet aspnet-codegenerator controller ^
        -name OrdersController -async -api ^
        -m Order ^
        -dc InventoryContext -outDir Controllers

    dotnet aspnet-codegenerator controller ^
        -name ReservationsController -async -api ^
        -m Reservation ^
        -dc InventoryContext -outDir Controllers
    ```

7.  Open the **BoilerPartController.cs** file in the **Controllers** folder, and add the **GetTotalReservations** method, shown below, to the **BoilerPartsController** class:

    ```csharp
    public class BoilerPartsController : ControllerBase
    {
        private readonly InventoryContext _context;

        public BoilerPartsController(InventoryContext context)
        {
            _context = context;
        }

        ...
        
        // GET: api/BoilerParts/5/Reserved 
        [HttpGet("{id}/Reserved")]
        public async Task<ActionResult<object>> GetTotalReservations(long id)
        { 
            var reservations = await _context
                .Reservations
                .Where(r => r.BoilerPartId == id) 
                .ToListAsync();

            int totalReservations = 0; 

            foreach(Reservation reservation in reservations) 
            { 
                totalReservations += reservation.NumberToReserve; 
            } 

            return new {id, totalReservations}; 
        }
        ...
    }
    ```

8.  Edit the **OrdersController.cs** file, and modify the **PostOrder** method in the **OrdersController** class as shown below:

    ```csharp
    [HttpPost]
    public async Task<ActionResult<Order>> PostOrder(long boilerPartId, int quantity)
    {
        var part = await _context.BoilerParts.FindAsync(boilerPartId);

        Order order = new Order 
        {
            BoilerPartId = boilerPartId,
            Quantity = quantity,
            OrderedDateTime = DateTime.Now,
            TotalPrice = quantity * part.Price
        };

        _context.Orders.Add(order);
        await _context.SaveChangesAsync();

        return CreatedAtAction("GetOrder", new { id = order.Id }, order);
    }
    ```

9.  Edit the **ReservationsController.cs** file. Modify the **PostReservation** method in the **ReservationsController** class as follows:

    ```csharp
    [HttpPost]
    public async Task<ActionResult<Reservation>> PostReservation(long boilerPartId, string engineerId, int quantityToReserve)
    {
        Reservation reservation = new Reservation 
        {
            BoilerPartId = boilerPartId,
            EngineerId = engineerId,
            NumberToReserve = quantityToReserve
        };

        _context.Reservations.Add(reservation);
        await _context.SaveChangesAsync();

        return CreatedAtAction("GetReservation", new { id = reservation.Id }, reservation);
    }
    ```

10. In the Terminal window, run the following commands to build and publish the Web API ready for deployment:

    ```
    dotnet build
    dotnet publish -c Release -o ./publish
    ```

11. In Visual Studio Code, right-click the **publish** folder, and then select **Deploy to Web App**:

Preeti can now update the Azure API Management service used by the VanArsdel app to reflect the updated Web API. This is a non-breaking change; existing operations will continue to work, the differences being the new controllers and operations to make reservations and place orders. Preeti performs the following tasks:

> **NOTE:**
> Preeti could have chosen to delete the existing Field Engineer API and replace it with a new version, but this approach risks breaking any existing applications that may be currently using the API. It's better practice to leave the existing API in place and add the modifications as a revision.

1.  In the Azure portal, go to the APIM service.

2.  On the **API Management service** page, in the left pane, under **APIs**, select **APIs**:

3.  Select the **Field Engineer API**, select the ellipsis menu, and then select **Add revision**:

    ![Add a revision to the Field Engineer API][198]

4.  In the **Create a new revision of the Field Engineer API** dialog box, enter the description **Added GET operation and POST operations for part reservations and orders**, and then select **Create**:

    ![Create the revision][199]

5.  On the **REVISION 2** page, select **Design**:

    ![Design the revision][200]

6.  On the **Design** page, select **Add operation**. In the **FrontEnd** pane, set the following properties, and then select **Save**. This operation is used for retrieving the number of items reserved for a given boiler part:

    -   Display name: **api/BoilerParts/{id}/Reserved**
    -   Name: **api-boilerparts-id-reserved**
    -   URL: **GET** **api/BoilerParts/{id}/Reserved**

    ![Add the Reserved API operation][201]

7.  On the **Test** tab for the new operation, set the **id** parameter to a valid part number (the example in the image uses part 1), and then select **Send**:

    ![Test the Web API][202]

8.  Verify that the test is successful. The operation should complete with an HTTP 200 response, and a body that shows the number of reservations for the product:

    ![The test response][203]

9.  On the **Design** page, select **Add operation**. In the **FrontEnd** pane, set the following properties. This operation defines POST requests for creating new orders:

    -   Display name: **api/Orders - POST**
    -   Name: **api-orders-post**
    -   URL: **POST** **api/Orders**

10. On the **Query** tab, select **+ Add parameter**, add the following parameters, and then select **Save**:

    -   Name: **boilerPartId**, Descripion**: Boiler Part ID**, Type: **long**
    -   Name: **quantity**, Descripion**: Quantity**, Type : **integer**

    ![Add parameters to APIM query operation][204]

11. Select **Add operation** again In the **FrontEnd** pane, and set the following properties. This operation defines POST requests for creating new reservations:

    -   Display name: **api/Reservations - POST**
    -   Name: **api-reservations-post**
    -   URL: **POST** **api/Reservations**

12. On the **Query** tab, add the following parameters, and then select **Save**:

    -   Name: **boilerPartId**, Descripion: **Boiler Part ID**, Type: **long**
    -   Name: **engineerId**, Description: **Engineer ID**, Type: **string**
    -   Name: **quantityToReserve**, Descripion: **Quantity to reserve**, Type: **integer**

13. On the **Revisions** tab, select the new version. On the ellipsis menu for this version, select **Make current**:

    ![Set the current version for the revision][205]

14. In the **Make revision current** dialog box, select **Save**.

15. Open another page in your web browser and go to the URL **https://*\<APIM name\>*.azure-api.net/api/boilerparts/1/reserved** where **\<APIM name\>** is the name of your API service. Verify that you get a response similar to the following:

    ```js
    {"id":1,"totalReservations":5}
    ```

The updated Web API is now available. In theory, Kiana could create a new custom connector for the updated Web API and add it to the app. The app could then implement its own logic to determine how many items of the specified product are currently in stock, how many are reserved, compare the results to the number of items required, place an order for more stock if necessary, or reserve items from the existing stock. However, this kind of logic is better implemented in an Azure Logic App. The Power Apps app can call the Logic App through a custom connector when a technician wishes to reserve or order a part.

To create the Logic App, Kiana uses the following steps:

> **NOTE:**
> To keep things simple, the Logic App created in this example is non-transactional. It's possible that between checking the availability of a part and making a reservation, a concurrent user might make a conflicting reservation. You could implement transactional semantics by replacing some of the logic in this Logic App with a stored procedure in the **InventoryDB** database.

1.  In the Azure portal, on the **Home** page, select **+ Create a resource**.

2.  In the **Search the marketplace** box, type **Logic App**, and then press **Enter**.

3.  On the **Logic App** page, select **Create**.

    ![Create the Logic App][206]

4.  On the **Create a logic app** page, enter the following values, and then select **Review + create**.

    -   Subscription: Select your Azure subscription
    -   Resource group: **webapi\_rg**
    -   Logic App name: **FieldEngineerPartsOrdering**
    -   Region: Select the same location you used for the Web API
    -   Associate with integration service environment: Leave blank
    -   Enable log analytics: Leave blank

5.  On the verification page, select **Create**, and wait while the Logic App is deployed.

6.  When the deployment is complete, select **Go to resource**.

7.  On the **Logic Apps Designer** page, scroll down to the **Templates** section, and then select **Blank Logic App**:

    ![Select the Blank Logic App template][207]

8.  On the **All** tab, in the **Search connectors and triggers** text box, select **Request**:

    ![Select the Request trigger][208] 

9.  On the **Triggers** tab, select **When a HTTP request is received**:

    ![Trigger when an HTTP request is received][209]

10. In the **Request Body JSON Schema** box, enter the following schema, and then select **+ New step**:

    ```js
    {
        "type": "object",
        "properties": {
            "boilerPartId": {
                "type": "integer"
            },
            "numberToReserve": {
                "type": "integer"
            },
            "engineerId": {
                "type": "string"
            }
        }
    }
    ```

    ![Logic App request schema][210]

    This schema defines the content of the HTTP request that the Logic App is expecting. The request body comprises the ID of a boiler part, the number of items to reserve, and the ID of the engineer making the request. The Power Apps app will send this request when an engineer wants to reserve a part.

11. In the **Choose an operation** box, select **All**, and then select **HTTP**:

    ![SelectH tthe HTTP operation option][211]

    The Logic App will call the **BoilerParts{id}** operation of the Web API to retrieve information about the boiler part provided by the request from the Power Apps app.

12. In the **Actions** pane, select the **HTTP** action:

    ![Select the HTTP action option][212]

13. In the **HTTP** action box, on the ellipsis menu, select **Rename**, and change the name of the action to **CheckBoilerPart**:

    ![Rename the HTTP action][213]

14. Set the properties of the HTTP action as follows, and then select **+ New Step**:

    -   Method: **GET**
    -   URI: **https://*\<APIM name\>*.azure-api.net/api/boilerparts/**, where ***\<APIM name\>*** is the name of your APIM service. In the **Dynamic content** box for this URI, on the **Dynamic content** tab, select **boilerPartId**

    ![Specify dynamic content for HTTP action][214]

15. In the **Choose an operation** box, in the **Search connectors and actions** box, enter **Parse JSON**, and then select the **Parse JSON** action:

    ![Select the Parse JSON action][215]

16. Using the ellipsis menu for the **Parse JSON** action, rename the action as **ParseBoilerPart**.

17. In the **Content** box for the **ParseBoilerPart** action, in the **Dynamic Content** box, select **Body**. In the **Schema** box, enter the following JSON schema, and then select **+ New step**:

    ```js
    {
        "type": "object",
        "properties": {
            "id": {
                "type": "integer"
            },
            "name": {
                "type": "string"
            },
            "categoryId": {
                "type": "string"
            },
            "price": {
                "type": "number"
            },
            "overview": {
                "type": "string"
            },
            "numberInStock": {
                "type": "integer"
            },
            "imageUrl": {
                "type": "string"
            },
        }
    }
    ```

    ![Parsing the BoilerPart object][216]

    This action parses the response message returned by the **getBoilerParts/{id} request. The response contains the details of the boiler part, including the number currently in stock.

18. In the **Choose an operation** box for the new step, select the **HTTP** connector.

19. On the **Actions** tab, select the **HTTP** action.

20. Using the ellipsis menu for the operation, rename the operation as **CheckReservations**.

21. Set the following properties for this operation, and then select **+ New step**:

    -   Method: **GET**
    -   URI: **https://*\<APIM name\>*.azure-api.net/api/boilerparts/**. As before, in the **Dynamic content** box for this URI, on the **Dynamic content** tab, select **boilerPartId**. In the **URI** field, append the text **/reserved** after the **boilerPartId** placeholder

    ![The CheckReservations step][217]

22. In the **Choose an operation** box for the new action, in the **Search connectors and actions** box, enter **Parse JSON**, and then select the **Parse JSON** action.

23. Rename the operation as **ParseReservations**.

24. Set the **Content** property to **Body**.

25. Enter the following schema, and then select **+ New step**:

    ```js
    {
        "type": "object",
        "properties": {
            "id": {
                    "type": "integer"
            },
            "totalReservations": {
                    "type": "integer"
            }
        }
    }
    ```

    ![Parsing the Reservations data][218]

26. In the **Choose an operation** box for the new action, in the **Search connectors and actions** box, enter **Condition**, and then select the **Condition Control** action:

    ![Select the Condition control][219]

27. Rename the operation as **CompareStock**.

28. Select the **Choose a value** box. In the **Add dynamic content** box, on the **Expression** tab, enter the following expression, and then select **OK**:

    ```
    add(body('ParseReservations')?['totalReservations'], triggerBody()?['numberToReserve'])
    ```

    This expression calculates the sum of the number of items of the specified boiler part that are currently reserved, and the number requested by the engineer.

    ![The CompareStock condition][220]

29. In the condition drop-down list box, select **is greater than**.

30. In the remaining **Choose a value** box, in the **Dynamic content** box, on the **Dynamic content** tab, under **ParseBoilerPart**, select **numberInStock**:

    ![Compare total reservations to number of items in stock][221]

31. If the number of items required plus the number reserved is greater than the number in stock, then the app needs to place an order to replenish the inventory. In the **True** branch of the **CompareStock** action, select **Add an action**.

32. On the **All** tab for the new operation, select **HTTP**, and then select the **HTTP** action.

33. Rename the operation as **PostOrder**.

34. Set the following properties for the **PostOrder** operation:

    -   Method: **POST**
    -   URI: **https://*\<APIM name\>*.azure-api.net/api/orders**
    -   In the **Queries** table, in the first row, enter the key **boilerPartId**. For the value in the **Add dynamic content** box, on the **Dynamic content** tab, select **boilerPartId **
    -   In the second row of the **Queries** table, enter the key **quantity**. In the value field, enter **50**:

    ![Post a request to order more parts][222]

    The Logic App will automatically order 50 items of the specified part when stock is running low.

    > **NOTE:**
    > The Logic App assumes that the engineer will nor actually attempt to reserve more than 50 items of a specified part in a single request!

35. Leave the **False** branch of the **CompareStock** action empty.

36. Below the **CompareStock** action, select **+ New step**.

37. On the **All** tab for the new operation, select **HTTP**, and then select the **HTTP** action.

38. Rename the operation as **PostReservation**.

39. Set the following properties for the **PostReservation** operation:

-   Method: **POST**
-   URI: **https://*\<APIM name\>*.azure-api.net/api/reservations**
-   In the **Queries** table, in the first row, enter the key **boilerPartId**. For the value in the **Add dynamic content** box, on the **Dynamic content** tab, select **boilerPartId**.
-   In the second row, enter the key **engineerId**. For the value in the **Add dynamic content** box, on the **Dynamic content** tab, select **engineerId**
-   In the third row, enter the key **quantityToReserve**. For the value in the **Add dynamic content** box, on the **Dynamic content** tab, select **numberToReserve**

40. Select **+ New Step**. In the **Choose an operation** box, search for and select the **Response** action.

41. Set the following properties for the **Response** action:

    -   Status Code: **200**
    -   Headers: Key - **content-type**, Value - **application/json**
    -   Body: In the **Dynamic content** box, select the **Body** element from the **PostReservation** request. This is the body returned when the reservation is made:

    ![Response message sent by the Logic App][223]

42. In the top left of the **Logic Apps Designer** page, select **Save**. Verify that the Logic App saves without any errors.

To create the custom connector that the Power Apps app can use to trigger the Logic App, Kiana performs the following steps while still in the Azure portal:

1.  On the **Overview** page for the Logic App, select **Export**.

    ![Export the Logic App][224]

2.  In the **Export to Power Apps** pane, name the connector **PartsOrderingConnector**, select your Power Apps environment**,** and then select **OK**.

    ![Export the LOgic App to Power Apps][225]

3.  Sign in to Power Apps Studio at <http://make.powerapps.com>.

4.  In your environment, under **Data**, select **Custom Connectors** and verify that the **PartsOrderingConnector** is listed:

    ![Power Apps custom connectors][226]

Maria can now modify the VanArsdel app to enable a technician to order parts while attending a customer site. She adds an **Order** button to the **PartDetails** screen.

1.  Sign in to Power Apps Studio at <http://make.powerapps.com> (if not already signed in).

2.  Under **Apps**, select the **VanArsdelApp** app. On the ellipsis menu for the app, select **Edit**.

3.  In the **Data** pane, select **Add data**, search for the **PartsOrderingConnector** connector, and add a new connection using this connector:

    ![Add the PartsOrdering connector to the app][227]

4.  In the **Tree view** pane, expand the **PartDetails** screen, and then expand the **DetailForm1** form.

5.  In the **Properties** pane on the right, select **Edit fields**. In the **Fields** pane, on the ellipsis menu, select **Add a custom card**:

    ![Add a custom data card control to the app][228]

6.  In the **Tree view** pane, rename the new card from **DataCard1** to **ReserveCard**. In the **Design view** window, resize the card so that it occupies the lower part of the screen, below the **Image\_DataCard1** control:

    ![Rename and resize the data card control][229]

7.  On the **Insert** menu, from the **Input** sub menu, add a **Text Input** control, a **Button** control, and a **Label** control to the **ReserveCard** control.

8.  Resize and position the controls so that they're adjacent, with the **Button** control to the right of the **Text Input** control, and the **Label** underneath the **Button** control.

9.  In the **Properties** pane for the **Text Input** control, clear the **Default** property.

10. In the **Properties** pane for the **Button** control, set the **Text** property to **Reserve**.

    ![The layout of the ParttDetails screen][230]

11. Rename the **Text Input** control as **NumberToReserve**, rename the **Button** control as **Reserve**, and rename the **Label** control as **Message**.

12. In the **Properties** pane for the **Message** control, set the **Text** property to **Parts Reserved**, and set the **Visible** property to **MessageIsVisible**.


    > **NOTE:**
    > **MessageIsVisible** is a variable that you will initialize to **false** when the screen is displayed, but is changed to **true** if the user hits the **Reserve** button.

13. Set the **OnSelect** property for the **Reserve** button control to the following formula:

    ```
    FieldEngineerPartsOrdering.manualinvoke({boilerPartId:ThisItem.id, engineerId:"ab9f4790-05f2-4cc3-9f01-8dfa7d848179", numberToReserve:NumberToReserve.Text});

    Set(MessageIsVisible, true);
    ```


    > **NOTE:**
    > This formula uses a hard-coded engineer ID to represent the technician currently running the app. Chapter 8 describes how to retrieve the ID for the logged-on user.
    >
    > Additionally, the app performs no error checking; it assumes that the request to reserve parts always succeeds. For more information on error handling, read **Errors function in Power Apps** at <https://docs.microsoft.com/powerapps/maker/canvas-apps/functions/function-errors>.

14. Set the **OnVisible** property for the **PartDetails** screen to **Set(MessageIsVisible, false)**.

To test the app:

1.  In the **Tree view** pane, select the **Home** screen.

2.  Press **F5** to preview the app.

3.  On the **Home** screen, select **Parts**.

4.  In the browse screen, select any part.

5.  On the **Part Details** screen, scroll down to the reservations section, enter a positive integer value, and then select **Reserve**. Verify that the **Parts reserved** message appears:

    ![The PartDetails screen with the Reserve function enabled][231]

6.  Close the preview window and return to Power Apps Studio.

7.  In the Azure portal, go to the page for the **InventoryDB** Azure SQL Database.

8.  Select the **Query editor**, and sign in as **sqladmin** with your password.

9.  In the **Query 1** pane, enter the following query, and then select Run. Verify that the reservation you made in the VanArsdel app appears:

    ```sql
    SELECT * FROM [dbo].[Reservations]
    ```

    ![The query results in Azure SQL Database][232]



Chapter 9: Conclusions
======================

Fusion development is not a strict methodology; rather, it's an approach and philosophy that encourages rapid software development.

Fusion development combines the technical and business skills of an organization's employees to design and build applications. This approach values the insights and abilities of the different members of the team. It utilizes their specific insights into the business requirements and technical challenges required to implement a solution. The synergy afforded by fusion development enables efficient communication between different team members and enables them to iterate quickly to produce a functional system.

In this guide, you've seen how the staff at VanArsdel followed a fusion development approach. They produced an app that meets the expectations of the users represented by Caleb, the technician, Maria, the inventory manager, and Malik, who schedules engineers. Preeti is also satisfied that the system is safe and maintainable. The project was completed in record time - from the initial discussions between Caleb and Maria, to the rollout to all technicians.

The VanArsdel team has now experienced how fusion development teams work and is excited to keep collaborating on future projects.

  [https://www.microsoft.com]: https://nam06.safelinks.protection.outlook.com/?url=https%3A%2F%2Fwww.microsoft.com%2F&data=04%7C01%7Cshboyer%40microsoft.com%7Cb1396d7184b84ff63cae08d8fa682a21%7C72f988bf86f141af91ab2d7cd011db47%7C1%7C0%7C637534672631280414%7CUnknown%7CTWFpbGZsb3d8eyJWIjoiMC4wLjAwMDAiLCJQIjoiV2luMzIiLCJBTiI6Ik1haWwiLCJXVCI6Mn0%3D%7C1000&sdata=rlcRH4u6zmBvIiC5IVCPgqbq%2FimkpV7QHQ2eW9Jd%2BmA%3D&reserved=0
    
  [1]: media/image1.png 
  [2]: media/image2.png 
  [3]: media/image3.png 
  [4]: media/image4.png 
  [5]: media/image5.png 
  [6]: media/image6.png 
  [7]: media/image7.png 
  [8]: media/image8.png 
  [9]: media/image9.png 
  [10]: media/image10.png 
  [11]: media/image11.png 
  [12]: media/image12.png 
  [13]: media/image13.png 
  [14]: media/image14.png 
  [15]: media/image15.png 
  [16]: media/image16.png 
  [17]: media/image17.png 
  [18]: media/image18.png 
  [19]: media/image19.png 
  [20]: media/image20.png 
  [21]: media/image21.png 
  [22]: media/image22.png 
  [23]: media/image23.png 
  [24]: media/image24.png 
  [25]: media/image25.png 
  [26]: media/image26.png 
  [27]: media/image27.png 
  [28]: media/image28.png 
  [29]: media/image29.png 
  [30]: media/image30.png 
  [31]: media/image31.png 
  [32]: media/image32.png 
  [33]: media/image33.png 
  [34]: media/image34.png 
  [35]: media/image35.png 
  [36]: media/image36.png 
  [37]: media/image37.png 
  [38]: media/image38.png 
  [39]: media/image39.png 
  [40]: media/image40.png 
  [41]: media/image41.png 
  [42]: media/image42.png 
  [43]: media/image43.png 
  [44]: media/image44.png 
  [45]: media/image45.png 
  [46]: media/image46.png 
  [47]: media/image47.png 
  [48]: media/image48.png 
  [49]: media/image49.png 
  [50]: media/image50.png 
  [51]: media/image51.png 
  [52]: media/image52.png 
  [53]: media/image53.png 
  [54]: media/image54.png 
  [55]: media/image55.png 
  [56]: media/image56.png 
  [57]: media/image57.png 
  [58]: media/image58.png 
  [59]: media/image59.png 
  [60]: media/image60.png 
  [61]: media/image61.png 
  [62]: media/image62.png 
  [63]: media/image63.png 
  [64]: media/image64.png 
  [65]: media/image65.png 
  [66]: media/image66.png 
  [67]: media/image67.png 
  [68]: media/image68.png 
  [69]: media/image69.png 
  [70]: media/image70.png 
  [71]: media/image71.png 
  [72]: media/image72.png 
  [73]: media/image73.png 
  [74]: media/image74.png 
  [75]: media/image75.png 
  [76]: media/image76.png 
  [77]: media/image77.png 
  [78]: media/image78.png 
  [79]: media/image79.png 
  [80]: media/image80.png 
  [81]: media/image81.png 
  [82]: media/image82.png 
  [83]: media/image83.png 
  [84]: media/image84.png 
  [85]: media/image85.png 
  [86]: media/image86.png 
  [87]: media/image87.png 
  [88]: media/image88.png 
  [89]: media/image89.png 
  [90]: media/image90.png 
  [91]: media/image91.png 
  [92]: media/image92.png 
  [93]: media/image93.png 
  [94]: media/image94.png 
  [95]: media/image95.png 
  [96]: media/image96.png 
  [97]: media/image97.png 
  [98]: media/image98.png 
  [99]: media/image99.png 
  [100]: media/image100.png 
  [101]: media/image101.png 
  [102]: media/image102.png 
  [103]: media/image103.png 
  [104]: media/image104.png 
  [105]: media/image105.png 
  [106]: media/image106.png 
  [107]: media/image107.png 
  [108]: media/image108.png 
  [109]: media/image109.png 
  [110]: media/image110.png 
  [111]: media/image111.png 
  [112]: media/image112.png 
  [113]: media/image113.png 
  [114]: media/image114.png 
  [115]: media/image115.png 
  [116]: media/image116.png 
  [117]: media/image117.png 
  [118]: media/image118.png 
  [119]: media/image119.png 
  [120]: media/image120.png 
  [121]: media/image121.png 
  [122]: media/image122.png 
  [123]: media/image123.png 
  [124]: media/image124.png 
  [125]: media/image125.png 
  [126]: media/image126.png 
  [127]: media/image127.png 
  [128]: media/image128.png 
  [129]: media/image129.png 
  [130]: media/image130.png 
  [131]: media/image131.png 
  [132]: media/image132.png 
  [133]: media/image133.png 
  [134]: media/image134.png 
  [135]: media/image135.png 
  [136]: media/image136.png 
  [137]: media/image137.png 
  [138]: media/image138.png 
  [139]: media/image139.png 
  [140]: media/image140.png 
  [141]: media/image141.png 
  [142]: media/image142.png 
  [143]: media/image143.png 
  [144]: media/image144.png 
  [145]: media/image145.png 
  [146]: media/image146.png 
  [147]: media/image147.png 
  [148]: media/image148.png 
  [149]: media/image149.png 
  [150]: media/image150.png 
  [151]: media/image151.png 
  [152]: media/image152.png 
  [153]: media/image153.png 
  [154]: media/image154.png 
  [155]: media/image155.png 
  [156]: media/image156.png 
  [157]: media/image157.png 
  [158]: media/image158.png 
  [159]: media/image159.png 
  [160]: media/image160.png 
  [161]: media/image161.png 
  [162]: media/image162.png 
  [163]: media/image163.png 
  [164]: media/image164.png 
  [165]: media/image165.png 
  [166]: media/image166.png 
  [167]: media/image167.png 
  [168]: media/image168.png 
  [169]: media/image169.png 
  [170]: media/image170.png 
  [171]: media/image171.png 
  [172]: media/image172.png 
  [173]: media/image173.png 
  [174]: media/image174.png 
  [175]: media/image175.png 
  [176]: media/image176.png 
  [177]: media/image177.png 
  [178]: media/image178.emf 
  [179]: media/image179.png 
  [180]: media/image180.png 
  [181]: media/image181.png 
  [182]: media/image182.png 
  [183]: media/image183.png 
  [184]: media/image184.png 
  [185]: media/image185.png 
  [186]: media/image186.png 
  [187]: media/image187.png 
  [188]: media/image188.png 
  [189]: media/image189.png 
  [190]: media/image190.png 
  [191]: media/image191.png 
  [192]: media/image192.png 
  [193]: media/image193.png 
  [194]: media/image194.png 
  [195]: media/image195.png 
  [196]: media/image196.png 
  [197]: media/image197.png 
  [198]: media/image198.png 
  [199]: media/image199.png 
  [200]: media/image200.png 
  [201]: media/image201.png 
  [202]: media/image202.png 
  [203]: media/image203.png 
  [204]: media/image204.png 
  [205]: media/image205.png 
  [206]: media/image206.png 
  [207]: media/image207.png 
  [208]: media/image208.png 
  [209]: media/image209.png 
  [210]: media/image210.png 
  [211]: media/image211.png 
  [212]: media/image212.png 
  [213]: media/image213.png 
  [214]: media/image214.png 
  [215]: media/image215.png 
  [216]: media/image216.png 
  [217]: media/image217.png 
  [218]: media/image218.png 
  [219]: media/image219.png 
  [220]: media/image220.png 
  [221]: media/image221.png 
  [222]: media/image222.png 
  [223]: media/image223.png 
  [224]: media/image224.png 
  [225]: media/image225.png 
  [226]: media/image226.png 
  [227]: media/image227.png 
  [228]: media/image228.png 
  [229]: media/image229.png 
  [230]: media/image230.png 
  [231]: media/image231.png 
  [232]: media/image232.png 
  [233]: media/image233.png 
  [234]: media/image234.png 
  [235]: media/image235.png 
  [236]: media/image236.png 
  [237]: media/image237.png 
  [238]: media/image238.png 
  [239]: media/image239.png 
  [240]: media/image240.png 
  [241]: media/image241.png 
  [242]: media/image242.png 
